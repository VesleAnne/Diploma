# Средство запуска NER для очистки набора ФИО

Состав проекта:
- `api` - исходный код для реализации взаимодействия модулей
- `model` - обученные модели на основе `spacy`
- `scripts` - исходный код
- `main.py`  - основной скрипт 
- `requirements.txt` - список зависимостей
- `FNdict` и `LNdict` - словари имен для предварительного поиска
- `docker-compose.yml` - файл запуска докер - контейнеров
- `Dockerfile-consumer` - файл загрузки модуля consumer в docker
- `Dockerfile-python` - файл запуска модуля python в docker
- `Dockerfile-sender` - файл запуска модуля sender в docker
- `go.mod`, `go.sum` - код загрузки зависимостей для взаимодействия API

---

## Настройка

Для корректной работы программы необходимо наличие установленных переменных среды:

Параметр|Значение по-умолчанию|Описание
-----|-----|-----
INPUT_NN_PATH| |Путь к директории `model-best`
INPUT_DETECTED| |Путь к директории `detected\model-best`
INPUT_TOKENIZER| |Путь к директории `tokenizer`
ADDR_MODEL| |Путь к директории модели адресной фильтрации
USE_ADDR_DETECT|1|\[0/1\] Флаг использования адресной фильтрации
FUZZY_SEARCH|False|\[True/False\] Использовать режим нечеткого поиска по словарю для увеличения качества детектирования строк (занимает много времени)
ADDR_RATIO|93|\[0-100\] коэффициент схожести по Левенштейну в процентах для адресной фильтрации
AMQP_SERVER_URL|amqp://guest:guest@localhost:5672|Адрес для подключения к rabbitmq формата ampq
QUEUE_NAME_IN|in|Название очереди сообщений необработанных строк
QUEUE_NAME_OUT|out|Название очереди сообщений обработанных строк
USE_GPU|True|\[True/False\] Использовать GPU для работы (необходима настройка CUDA)
USE_NN_ONLY|0|\[0/1\] \[Тестовый режим\] Отключить использование словаря, все сущности будут распознаваться моделью (может быть медленнее)
REDIS_HOST|redis-ner|Хост Redis
REDIS_PORT|6379|Порт Redis
SAVE_FILE|0|\[0/1\] Флаг сохранения файла обработанных строк
OUT_FILE_PATH|./errors|Путь к директории сохранения файлов ошибок при тестировании
STR_MAX_TOKENS|7|Фильтр количества слов входной строки для именных сущностей
CHUNK_SIZE|25000|Количество строк для передачи в 1 инстанс программы

## Запуск проекта

- Все пути к директориям должны быть относительными и находиться внутри папки проекта (в противном случае они будут недоступны изнутри контейнера)
- Значения хоста и порта для Redis и Rabbitmq должны иметь значения по умолчанию

### Запуск в docker-контейнере

1. Запустите терминал и перейдите в корневую директорию проекта
2. Выполните команду `docker-compose up` (при первом запуске потребуется подключение к Интернет для создания контейнеров)

### Запуск с использованием GPU

1. Запустите терминал и перейдите в корневую директорию проекта
2. Удалить, если есть, ранее собранные контейнеры для CPU
3. Выполните команду `docker-compose -f docker-compose.yml -f docker-compose-gpu.yml up` (при первом запуске потребуется подключение к Интернет для создания контейнеров)

---

## Архитектура проекта и результаты работы.

На вход программы необходимо подавать строки БД для поиска именованных сущностей, представляющие собой json - запрос следующего формата:
```json
{
  "sessionId": "2a8bacfa-7558-11ed-b6da-0242ac120005",
  "data": [
    {
      "id": 0,
      "string": "ivan ivanov abracadabra2"
    },
    {
      "id": 1,
      "string": "iva(n ivan0ov"
    },
    {
      "id": 2,
      "string": "abacadabraasfsa"
    },
    {
      "id": 3,
      "string": "ivan"
    },
  ]
}
```
Где:
- `sessionId` - идентификатор сессии,
- `data` - массив строк сообщения для обработки. Каждая строка состоит из:
  - `id` - идентификатор строки сообщения,
  - `string` - непосредственно текстовые данные для анализа.

Данные, поданные на вход программы, считываются и преобразуются непосредственно для построчной обработки.

Далее, каждая строка проходит процесс предобработки и нормализации в модуле `Normilizer.py` проекта.
Выход модуля представляет собой исходную строку и нормализованную строку. 
Дальнейшая работа с поиском сущностей производится непосредственно с объектом нормализованной строки. 

Детектирование адресов происходит с помощью нейросетевой модели. Поданная на вход данного модуля строка разбивается на токены (словоформы) внутреннего формата модуля spaCy, далее преобразованные данные обрабатываются непосредственно нейросетью, 
после чего на входе каждому токену присваивается некоторый признак, относится ли объект к именной группе или нет. Если относится, также производится классификация его как адрес/не адрес. 
Сущности, распознанные как не адрес, а также нераспознанные сущности, подаются на вход модели детектора ФИО. Выходом функции нейросетевого поиска являются обнаруженные именованные сущности, также с разделением адреса/не адреса 
и оставшаяся часть строки, не распознанная как адрес - группа.

При поиске именованных сущностей, согласно установленному параметру `STR_MAX_TOKENS`, любая строка большего размера будет интерпретирована как not_person и дальнейшая ее обработка происходить не будет.
Детектирование именованных сущностей в нормализованной строке происходит сначала посредством поиска по словарю (если указан режим тестирования нейросети `USE_NN_ONLY` нормализованная строка никак не изменяется и подается сразу на вход поиска нейросетевой модели).
Словарный поиск использует Redis DB и словари FNdict и LNdict для поиска имен и фамилий соответственно.
Функция словарного поиска: на вход модуля `dictionary_search dict_search.py` поступает нормализованная строка и ранее отфильтрованные 
сущности модуля `Normilizer.py`, поиск по которым не осуществляется. Результат работы данной функции - найденные именные группы в нормализованной строке, в том числе с разделением 
на имена/фамилии, а также формирование входной строки для нейросетевой модели поиска из тех сущностей строки, которые распознать как именные группы не удалось. 

Поиск именованных сущностей посредством нейросети происходит в модуле ner_model.py. Решение задачи детектирования ФИО посредством нейросети происходило в 2 этапа: 
1. Отбор ранее предобученных стандартных моделей BERT, для представления общей модели языка spaCy. 
2. Процесс тонкой настройки выбранных моделей, посредством доообучения и коррекции сети под конкретную задачу поиска именованных сущностей. 

Поданная на вход данного модуля строка разбивается на токены (словоформы) внутреннего формата модуля spaCy, далее преобразованные данные обрабатываются непосредственно нейросетью, 
после чего на входе каждому токену присваивается некоторый признак, относится ли объект к именной группе или нет. Если относится, также производится классификация его как имя или фамилия. 
Выходом функции нейросетевого поиска являются обнаруженные именованные сущности, также с разделением на имена/фамилии 
и оставшаяся часть строки, не распознанная как ФИО - группа.

Далее результаты трех модулей поиска объединяются и записываются в единый фрейм результата работы программы. Из данного фрейма будет сформирован json-ответ следующего формата:
```json
{
  "sessionId": "2a8bacfa-7558-11ed-b6da-0242ac120005",
  "message": "ready",
  "tokens": [
    {
      "id": 0,
      "error": false,
      "FN": "ivan",
      "LN": "ivanov",
      "location": "",
      "not_person": "abrakadabra",
      "flag_person": 3
    },
    {
      "id": 1,
      "error": false,
      "FN": "ivan",
      "LN": "ivanov",
      "location": "",
      "not_person": "",
      "flag_person": 2
    },
    {
      "id": 2,
      "error": true,
      "FN": "",
      "LN": "",
      "location": "",
      "not_person": "abacadabraasfsa",
      "flag_person": 4
    },
    {
      "id": 3,
      "error": false,
      "FN": "ivan",
      "LN": "",
      "location": "",
      "not_person": "",
      "flag_person": 0
    },
    {
      "id": 4,
      "error": true,
      "input_str": "01135 м. Київ, пр-т Перемоги, 10",
      "FN": "",
      "LN": "",
      "location": "01135 м. Київ, пр-т Перемоги, 10",
      "not_person": "",
      "flag_person": 5
}
    
  ]
}
```
Где:
- `sessionId` - идентификатор сессии,
- `message` - поле-идентификатор состояния обработки сообщения:
  - значение `ready` - сообщение успешно обработано
  - значение `error` - сообщение сформировано неверно и возникла ошибка при его обработке
  - значение `waiting` - сообщение находится в обработке
- `tokens` - представляет собой массив обработанных строк исходного сообщения:
  - `id` - идентификатор строки сообщения,
  - `error` - идентификатор ошибки, если именованных сущностей в строке не обнаружено (может быть true/false),
  - `FN` - фрагмент именованной сущности, найденный в исходной строке, идентифицированный модулем поиска, как «имя»,
  - `LN` - фрагмент именованной сущности, найденный в исходной строке, идентифицированный модулем поиска, как «фамилия»,
  - `not_person` - остаточный фрагмент строки, именных сущностей в котором не найдено программным модулем поиска
  - `flag_person` - флаг наличия person сущностей в строке:
    - 0 - строка на входе полностью имя (John)
    - 1 - строка на входе полностью фамилия (Smith)
    - 2 - строка на входе полностью имя + фамилия (John Smith)
	- 3 - строка на входе не является полностью person, но содержит в себе person (Ph.D. John Smith)
	- 4 - строка на входе не содержит person сущностей и адресов (test string)
    - 5 - строка на входе является адресом(м. Київ, вул. Московська, 8, корп. 5)

## API

В качестве интерфейса для пользователя предоставляется REST API со следующими эндпойнтами:

**POST /api/send** - отправка пакета данных для анализа на NER
- Параметры: нет
- Тело запроса: JSON с пакетом данных согласно спецификации
например,
```json
{
  "sessionId": "1",
  "data": [
    {
      "id": 0,
      "string": "vas1ya pupk8in abrakadabra"
    },
    {
      "id": 1,
      "string": "iva(n ivan0ov abrakadabra"
    }
  ]
}
```

**POST /api/send/file** - отправка файла с данными для анализа на NER
- Параметры: нет
- Тело запроса: набор записей (строк) в простом текстовом формате

> Каждая запись должна оканчиваться переводом строки ("\n","\r","\r\n"). Пустые строки игнорируются.

например:
```
alexan1der shish1kin abrakadabra
pe)ter pet!rovichev abrakadabra
pete!r izmail!ov abrakadabra
alex8ey and1ronov abrakadabra
```

- Ответ: JSON со сгенерированным SID
```json
{
    "message": "data sent for processing",
    "sid": "6313d7d3-7559-11ed-b6da-0242ac120005"
}
```

Пример запроса для отправки файла с использованием curl:

`$ curl -X POST --data-binary @test.txt http://localhost:3001/api/send/file`

**GET /api/get** - получение всех результатов
- Параметры: нет
- Тело запроса: нет
- Ответ: JSON с результатами обработанных строк
например,
```json
[
    {
        "sessionId": "3fc55962-7603-11ed-bca1-0242ac120002",
        "message": "ready",
        "tokens": [
            {
                "id": 0,
                "error": false,
                "FN": "alexander",
                "LN": "shishkin",
                "location": "",
                "not_person": "abrakadabra",
                "flag_person": 3
            },
            {
                "id": 1,
                "error": false,
                "FN": "peter",
                "LN": "petrovichev",
                "location": "",
                "not_person": "abrakadabra",
                "flag_person": 3
            },
            {
                "id": 2,
                "error": false,
                "FN": "peter",
                "LN": "izmailov",
                "location": "",
                "not_person": "abrakadabra",
                "flag_person": 3
            },
            {
                "id": 3,
                "error": false,
                "FN": "alexey",
                "LN": "andronov",
                "location": "",
                "not_person": "abrakadabra",
                "flag_person": 3
            }, 
            {
                "id": 4,
                "error": true,
                "input_str": "01135 м. Київ, пр-т Перемоги, 10",
                "FN": "",
                "LN": "",
                "location": "01135 м. Київ, пр-т Перемоги, 10",
                "not_person": "",
                "flag_person": 5
            }
        ]
    },
    {
        "sessionId": "7b0900e8-7603-11ed-bca1-0242ac120002",
        "message": "ready",
        "tokens": [
            {
                "id": 0,
                "error": false,
                "FN": "alexander",
                "LN": "shishkin",
                "location": "",
                "not_person": "abrakadabra",
                "flag_person": 3
            },
            {
                "id": 1,
                "error": false,
                "FN": "peter",
                "LN": "petrovichev",
                "location": "",
                "not_person": "abrakadabra",
                "flag_person": 3
            },
            {
                "id": 2,
                "error": false,
                "FN": "peter",
                "LN": "izmailov",
                "location": "",
                "not_person": "abrakadabra",
                "flag_person": 3
            },
            {
                "id": 3,
                "error": false,
                "FN": "alexey",
                "LN": "andronov",
                "location": "",
                "not_person": "abrakadabra",
                "flag_person": 3
            },
            {
                "id": 4,
                "error": true,
                "input_str": "01135 м. Київ, пр-т Перемоги, 10",
                "FN": "",
                "LN": "",
                "location": "01135 м. Київ, пр-т Перемоги, 10",
                "not_person": "",
                "flag_person": 5
            }
        ]
    }
]
```

**GET /api/get/\{sid\}** - получение результатов по конкретному SessionID
- Параметры: \{sid\} - обязательный - string
- Тело запроса: нет
- Ответ: JSON с результатами обработанных строк для конкретного SessionID
например,
```json
{
  "sessionId": "2a8bacfa-7558-11ed-b6da-0242ac120005",
  "message": "ready",
  "tokens": [
    {
      "id": 0,
      "error": false,
      "FN": "alexander",
      "LN": "shishkin",
      "location": "",
      "not_person": "abrakadabra",
      "flag_person": 3
    },
    {
      "id": 1,
      "error": false,
      "FN": "peter",
      "LN": "petrovichev",
      "location": "",
      "not_person": "abrakadabra",
      "flag_person": 3
    },
    {
      "id": 2,
      "error": false,
      "FN": "peter",
      "LN": "izmailov",
      "location": "",
      "not_person": "abrakadabra",
      "flag_person": 3
    },
    {
      "id": 3,
      "error": false,
      "FN": "alexey",
      "LN": "andronov",
      "location": "",
      "not_person": "abrakadabra",
      "flag_person": 3
    }
  ]
}
```

---

## Описание метрик НС (файлы `\model\..\meta.json`)

**Параметры качества**

- **ents_f** - метрика F1 - среднее гармоническое между ents_p и ents_r метриками, показатель метрики является балансом между ents_p и ents_r

- **ents_p** - метрика precision - точность, показатель показывающий точность принадлежности объекта одному из классов

- **ents_r** - метрика recall - способность модели находить классы из множества объектов. В NER задачах оценка качества модели оценивается по метрике F1

**Cущности NER**

- **PERSON** - способность модели находить класс PERSON во входных строках (например, John A Smith)
- **PERSON_SOLO** - способность модели находить класс PERSON во входных строках с количеством токенов равным 1(например, отличить John от footbal)
- **0** - способность модели детектировать входной мусор (например, sdzxcxzc)
- **LOC** - способность модели детектировать топонимы и адреса (например, Bethel Cemetery)
- **ORG** - способность модели детектировать организации (например, Aegis Group PLC)

## Использование графического ускорителя (GPU)

Ускорение программы с помощью графического ядра производится только на картах *NVIDIA* с поддержкой *CUDA*. 
Для выполнения программы с поддержкой *GPU* необходимо установить драйвера *NVIDIA* и соответствующие *CUDA*- пакеты.
Во избежание ошибки *CUDA Out Of Memory*, параметр **CHUNK_SIZE** необходимо подбирать эмпирически под существующую видеокарту. 
По умолчанию указан максимальный размер **CHUNK_SIZE = 25000**, для видеокарты NVIDIA GeForce RTX 3070 (8GB memory)
Также следует учесть, что не все видеокарты поддерживают технологию *Multi-Instance GPU* (запуск нескольких 
экземпляров программы на одном графическом ускорителе)
Более подробно о технологии *MIG* указано здесь https://docs.nvidia.com/datacenter/tesla/mig-user-guide/index.html


## Использование параллельной обработки на CPU

Для параллельной обработки на CPU необходимо выполнить следующие действия
При наличии одной видеокарты, при флаге **USE_GPU = 'True'** и запуске нескольких экземпляров программы с помощью 
Docker, 1 экземпляр анализатора будет выполняться на графическом ускорителе в то время как остальные на CPU.

1. В файле `docker-compose.yml` скопировать секцию `analyzer`
```
    analyzer:
        build:
          context: .
          dockerfile: Dockerfile-python
        environment:
          CHUNK_SIZE: "${CHUNK_SIZE}"
          FUZZY_SEARCH: "${FUZZY_SEARCH}"
          QUEUE_NAME_IN: "${QUEUE_NAME_IN}"
          AMQP_SERVER_URL: "${AMQP_SERVER_URL}"
          QUEUE_NAME_OUT: "${QUEUE_NAME_OUT}"
          INPUT_NN_PATH: "${INPUT_NN_PATH}"
          INPUT_DETECTED: "${INPUT_DETECTED}"
          INPUT_TOKENIZER: "${INPUT_TOKENIZER}"
          USE_GPU: "${USE_GPU}"
          USE_NN_ONLY: "${USE_NN_ONLY}"
          REDIS_HOST: "${REDIS_HOST}"
          REDIS_PORT: "${REDIS_PORT}"
          SAVE_FILE: "${SAVE_FILE}"
          OUT_FILE_PATH: "${OUT_FILE_PATH}"
          ADDR_MODEL: "${ADDR_MODEL}"
          USE_ADDR_DETECT: "${USE_ADDR_DETECT}"
          ADDR_RATIO: "${ADDR_RATIO}"
          STR_MAX_TOKENS: "${STR_MAX_TOKENS}"
        container_name: python-ner
        restart: always
        depends_on:
            - redis
        networks:
            - ner-network
        deploy:
            resources:
                reservations:
                    devices:
                        - driver: nvidia
                          count: 1
                          capabilities: [gpu]
```
2. Переименовать параметр ```analyzer``` любым индивидуальным строковым значением
3. Изменить переменную строки ```container_name:``` с ```python-ner``` на любое индивидуальное строковое значение
4. Перезапустить docker-compose с помощью команды `sudo docker-compose up`

В случае наличия нескольких видеокарт, возможно параллельная обработка с применением *GPU*.
Для этого необходимо поменять параметр *count* c 1, на ID используемой *GPU* в секции ниже.
Для каждого экземпляра должен быть указан свой ID.
```
        deploy:
            resources:
                reservations:
                    devices:
                        - driver: nvidia
                          count: 0
                          capabilities: [gpu]
```

